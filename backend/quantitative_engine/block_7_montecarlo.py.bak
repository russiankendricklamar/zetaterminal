# backend/quantitative_engine/block_7_montecarlo.py
# -*- coding: utf-8 -*-

import numpy as np
from typing import Tuple, Dict
from core.numba_kernels import mc_simulate_paths  # â† IMPORT JIT

def simulate_montecarlo(mu: np.ndarray, sigma: np.ndarray, weights: np.ndarray,
                       X_0: float, T: float, n_paths: int = 5000,
                       asset_names: list = None) -> Tuple[np.ndarray, np.ndarray, Dict]:
    
    """
    Monte Carlo simulation with Numba acceleration
    """
    
    mu = np.asarray(mu).flatten()
    sigma = np.asarray(sigma)
    weights = np.asarray(weights).flatten()
    
    n_assets = len(mu)
    
    if asset_names is None:
        asset_names = [f'Asset_{i}' for i in range(n_assets)]
    
    # Time grid
    n_steps = int(T * 252)
    if n_steps < 2: 
        n_steps = 2
    
    t_grid = np.linspace(0, T, n_steps)
    dt = T / (n_steps - 1)
    
    # ============ KEY OPTIMIZATION: Compute Cholesky ONCE ============
    try:
        L = np.linalg.cholesky(sigma)  # Compute outside JIT loop
    except np.linalg.LinAlgError:
        # Fallback if not positive definite
        eigenvalues, eigenvectors = np.linalg.eigh(sigma)
        eigenvalues = np.maximum(eigenvalues, 1e-8)  # Ensure positive
        L = eigenvectors @ np.diag(np.sqrt(eigenvalues))
    
    # ============ CALL JIT-COMPILED FUNCTION ============
    X_paths = mc_simulate_paths(
        mu=mu,
        L=L,
        weights=weights,
        X_0=X_0,
        T=T,
        n_paths=n_paths,
        n_steps=n_steps,
        seed=42
    )
    
    # Asset paths (still NumPy, can optimize later)
    asset_paths_dict = {}
    for asset_name in asset_names:
        asset_paths_dict[asset_name] = np.zeros((n_paths, n_steps))
        asset_paths_dict[asset_name][:, 0] = X_0 / n_assets
    
    port_mu = np.dot(weights, mu)
    port_var = np.dot(weights, np.dot(sigma, weights))
    port_vol = np.sqrt(port_var)
    drift_port = (port_mu - 0.5 * port_var) * dt
    
    # Simulate individual assets (parallel opportunity)
    np.random.seed(42)
    L = np.linalg.cholesky(sigma)
    Z = np.random.normal(0, 1, (n_assets, n_paths, n_steps - 1))
    
    for step in range(n_steps - 1):
        dW_assets = np.dot(L, Z[:, :, step]) * np.sqrt(dt)
        
        for i, asset_name in enumerate(asset_names):
            asset_mu = mu[i]
            asset_vol = np.sqrt(sigma[i, i])
            asset_drift = (asset_mu - 0.5 * sigma[i, i]) * dt
            asset_diffusion = asset_vol * dW_assets[i, :]
            
            asset_paths_dict[asset_name][:, step + 1] = (
                asset_paths_dict[asset_name][:, step] * 
                np.exp(asset_drift + asset_diffusion)
            )
            
            asset_paths_dict[asset_name][asset_paths_dict[asset_name][:, step + 1] < 1e-6, step + 1] = 1e-6
    
    return X_paths, t_grid, asset_paths_dict